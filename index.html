<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini ç²’å­äº¤äº’ - çˆ±å¿ƒä¼šå®</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #video-container {
            position: absolute; top: 0; left: 0; width: 1px; height: 1px;
            opacity: 0; pointer-events: none; z-index: -1;
        }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px;
            background: rgba(15, 15, 15, 0.85); backdrop-filter: blur(20px);
            padding: 20px; border-radius: 18px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white; z-index: 100; width: 260px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.8);
        }

        h1 { font-size: 16px; margin: 0 0 15px 0; color: #fff; font-weight: 600; text-align: center; letter-spacing: 2px;}
        
        /* 3åˆ—å¸ƒå±€ï¼Œå®¹çº³æ›´å¤šæŒ‰é’® */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        
        button {
            background: rgba(255, 255, 255, 0.08); border: none; color: #aaa;
            padding: 10px 5px; border-radius: 8px; cursor: pointer; transition: 0.2s;
            font-size: 12px; display: flex; flex-direction: column; align-items: center; gap: 4px;
        }
        button:hover { background: rgba(255, 255, 255, 0.2); color: #fff; transform: scale(1.05); }
        button.active { background: rgba(66, 133, 244, 0.3); color: #4285f4; border: 1px solid rgba(66, 133, 244, 0.5); box-shadow: 0 0 10px rgba(66,133,244,0.2); }

        #status { font-size: 12px; color: #888; display: flex; align-items: center; justify-content: center; margin-top: 10px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 50px;}
        .dot { width: 8px; height: 8px; background: #555; border-radius: 50%; margin-right: 8px; transition: 0.3s; }
        .dot.active { background: #0f0; box-shadow: 0 0 8px #0f0; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: #fff; font-size: 16px; pointer-events: none; text-align: center;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
        }
    </style>
    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        æ­£åœ¨ä¸‹è½½ AI æ¨¡å‹ (çº¦10MB)...<br>
        <span style="font-size:12px; color:#aaa; display:block; margin-top:10px;">å¦‚æœé•¿æ—¶é—´å¡ä½ï¼Œè¯·ä¸è¦ç›´æ¥åŒå‡»æ‰“å¼€ HTML<br>è¯·ä½¿ç”¨ Live Server æˆ–æœ¬åœ°æœåŠ¡å™¨è¿è¡Œ</span>
    </div>

    <div id="ui-panel">
        <h1>ğŸŒŒ ç²’å­æ§åˆ¶å°</h1>
        <div class="btn-grid">
            <button onclick="changeShape('heart')" class="active">â¤ï¸ çˆ±å¿ƒ</button>
            <button onclick="changeShape('galaxy')">ğŸŒ€ æ˜Ÿç³»</button>
            <button onclick="changeShape('dna')">ğŸ§¬ DNA</button>
            
            <button onclick="changeShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
            <button onclick="changeShape('cube')">ğŸ§Š ç«‹æ–¹</button>
            <button onclick="changeShape('sphere')">ğŸ”® çƒä½“</button>
            
            <button onclick="changeShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
            <button onclick="changeShape('buddha')">ğŸ§˜ ä½›åƒ</button>
            <button onclick="changeShape('text')">ğŸ‡¨ğŸ‡³ ä¼šå®</button>
        </div>
        
        <input type="color" id="colorPicker" value="#4285f4" style="width:100%; height:30px; border:none; background:none; cursor:pointer;">
        
        <div id="status">
            <div class="dot" id="status-dot"></div>
            <span id="status-text">ç­‰å¾…æ‘„åƒå¤´æƒé™...</span>
        </div>
    </div>

    <div id="video-container"><video id="input-video"></video></div>

    <script>
        // --- 1. Three.js åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 32;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 2. ç²’å­ç³»ç»Ÿ (å¢åŠ æ•°é‡) ---
        const particleCount = 25000; 
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3);
        const randomOffsets = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 100;
            targetPositions[i] = positions[i];
            randomOffsets[i] = (Math.random() - 0.5); // ç”¨äºçˆ†ç‚¸æ—¶çš„éšæœºæ•£å°„
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0x4285f4,
            size: 0.25,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 3. å½¢çŠ¶ç®—æ³•åº“ (å…¨æ”¶å½• + ä¼˜åŒ–çˆ±å¿ƒ) ---
        
        // ä¼˜åŒ–ï¼šå®å¿ƒçˆ±å¿ƒï¼ˆä¸ä»…ä»…æ˜¯çº¿æ¡ï¼‰
        function getPointOnHeart() {
            // ä½¿ç”¨è’™ç‰¹å¡æ´›æ–¹æ³•æˆ–å¤šå±‚å åŠ ï¼Œè¿™é‡Œç”¨ç®€å•çš„éšæœºåç§»å¡«å……å†…éƒ¨
            const t = Math.random() * Math.PI * 2;
            // å¿ƒå½¢æ›²çº¿
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            
            // å…³é”®ï¼šä¹˜ä»¥ä¸€ä¸ªéšæœºæ•° sqrt(random) æ¥å¡«å……å†…éƒ¨ï¼Œè€Œä¸æ˜¯åªåœ¨è¾¹ç¼˜
            const scale = Math.sqrt(Math.random()); 
            // åŠ ä¸Š Z è½´åšåº¦
            const z = (Math.random() - 0.5) * 6 * scale; // è¾¹ç¼˜è–„ï¼Œä¸­é—´åš

            return { 
                x: x * scale * 0.5, 
                y: y * scale * 0.5, 
                z: z 
            };
        }

        function getPointOnSphere() {
            const r = 10;
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        function getPointOnCube() {
            const size = 14; 
            // å®å¿ƒç«‹æ–¹ä½“ (ä¸ä»…ä»…æ˜¯è¡¨é¢)
            return {
                x: (Math.random() - 0.5) * size,
                y: (Math.random() - 0.5) * size,
                z: (Math.random() - 0.5) * size
            };
        }
        
        function getPointOnSaturn() {
            // 70% ç²’å­åšæ˜Ÿçƒï¼Œ30% åšå…‰ç¯
            if (Math.random() > 0.3) {
                // æ˜Ÿçƒæœ¬ä½“
                const p = getPointOnSphere();
                return { x: p.x * 0.8, y: p.y * 0.8, z: p.z * 0.8 };
            } else {
                // å…‰ç¯
                const angle = Math.random() * Math.PI * 2;
                const r = 12 + Math.random() * 6;
                return {
                    x: r * Math.cos(angle),
                    y: (Math.random() - 0.5) * 0.5, // æè–„
                    z: r * Math.sin(angle)
                };
            }
        }

        function getPointOnFlower() {
            const angle = Math.random() * Math.PI * 2;
            const r = 10 * Math.sin(5 * angle); // 5ç“£
            const phi = (Math.random() - 0.5) * Math.PI;
            // ç¨å¾®æœ‰ç‚¹åšåº¦
            return {
                x: r * Math.cos(angle) * Math.cos(phi),
                y: r * Math.sin(angle) * Math.cos(phi),
                z: r * Math.sin(phi) * 0.5
            };
        }

        function getPointOnGalaxy() {
            const arms = 5;
            const armAngle = (Math.random() * Math.PI * 2 * arms);
            const distance = Math.random() * 15;
            const angle = armAngle / arms + distance * 0.5;
            return {
                x: Math.cos(angle) * distance,
                y: (Math.random() - 0.5) * (15 - distance) * 0.2, // ä¸­å¿ƒåšè¾¹ç¼˜è–„
                z: Math.sin(angle) * distance
            };
        }

        function getPointOnDNA(i, total) {
            const t = (i / total) * 30;
            const r = 5;
            return {
                x: r * Math.cos(t),
                y: (i / total - 0.5) * 35,
                z: r * Math.sin(t) + (i % 2 === 0 ? 3 : -3) // åŒé“¾åç§»
            };
        }

        function createTextPoints(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 200; canvas.height = 200;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 100px "Microsoft YaHei"';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);
            const data = ctx.getImageData(0, 0, 200, 200).data;
            const points = [];
            // é™ä½é‡‡æ ·æ­¥é•¿ï¼Œè·å¾—æ›´å¤šç‚¹
            for (let y = 0; y < 200; y += 2) {
                for (let x = 0; x < 200; x += 2) {
                    if (data[(y * 200 + x) * 4 + 3] > 128) {
                        points.push({
                            x: (x - 100) * 0.15,
                            y: -(y - 100) * 0.15,
                            z: (Math.random() - 0.5) * 3 // å¢åŠ æ–‡å­—åšåº¦
                        });
                    }
                }
            }
            return points;
        }

        // --- 4. å½¢çŠ¶åˆ‡æ¢é€»è¾‘ ---
        let currentShape = 'heart';
        
        function updateTargetPositions(shape) {
            let textPoints = [];
            if (shape === 'text') textPoints = createTextPoints("ä¼šå®");
            if (shape === 'buddha') textPoints = createTextPoints("ä½›");

            for (let i = 0; i < particleCount; i++) {
                let p = {x:0, y:0, z:0};
                
                switch(shape) {
                    case 'heart': p = getPointOnHeart(); break;
                    case 'sphere': p = getPointOnSphere(); break;
                    case 'cube': p = getPointOnCube(); break;
                    case 'saturn': p = getPointOnSaturn(); break;
                    case 'flower': p = getPointOnFlower(); break;
                    case 'galaxy': p = getPointOnGalaxy(); break;
                    case 'dna': p = getPointOnDNA(i, particleCount); break;
                    case 'text': 
                    case 'buddha':
                        if (textPoints.length > 0) {
                            const tp = textPoints[i % textPoints.length];
                            p = { x: tp.x * 1.5, y: tp.y * 1.5, z: tp.z };
                        }
                        break;
                }
                
                targetPositions[i * 3] = p.x;
                targetPositions[i * 3 + 1] = p.y;
                targetPositions[i * 3 + 2] = p.z;
            }
        }

        updateTargetPositions('heart');

        window.changeShape = (s) => {
            currentShape = s;
            updateTargetPositions(s);
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
        };

        document.getElementById('colorPicker').addEventListener('input', (e) => material.color.set(e.target.value));

        // --- 5. MediaPipe æ‰‹åŠ¿è¯†åˆ« (é«˜çµæ•åº¦é…ç½®) ---
        let handOpenness = 0; // å½“å‰å¹³æ»‘å€¼
        let targetOpenness = 0; // ç›®æ ‡å€¼

        const video = document.getElementById('input-video');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('active');
                statusText.innerText = "å·²è¿æ¥ - è¯·å¼ åˆæ‰‹æŒ";
                
                const lm = results.multiHandLandmarks[0];
                const d = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));

                // çµæ•åº¦æ˜ å°„ï¼š
                // è·ç¦» 0.03 (ç´§é—­) -> 0
                // è·ç¦» 0.12 (ç¨å¾®å¼ å¼€) -> 1.0 (å…¨å¼€)
                // è¿™æ ·è®¾ç½®ï¼Œç¨å¾®åŠ¨ä¸€ä¸‹æ‰‹æŒ‡ï¼Œæ•ˆæœå°±å¾ˆæ˜æ˜¾
                let val = (d - 0.03) * 11.0; 
                targetOpenness = Math.max(0, Math.min(1, val));

            } else {
                statusDot.classList.remove('active');
                statusText.innerText = "å¯»æ‰¾æ‰‹åŠ¿...";
                targetOpenness = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1, // 1 æ˜¯æ ‡å‡†æ¨¡å‹ï¼Œå¦‚æœå¤ªå¡å¯ä»¥æ”¹æˆ 0 (Lite)
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(video, {
            onFrame: async () => {
                await hands.send({image: video});
            },
            width: 320, // é™ä½åˆ†è¾¨ç‡ä»¥æé«˜æ€§èƒ½
            height: 240
        });
        
        // å°è¯•å¯åŠ¨æ‘„åƒå¤´ï¼Œå¢åŠ é”™è¯¯å¤„ç†
        cameraUtils.start().catch(err => {
            console.error(err);
            document.getElementById('loading').innerHTML = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·æ£€æŸ¥æµè§ˆå™¨æƒé™æˆ–ä½¿ç”¨ HTTPS/Localhost";
        });

        // --- 6. æé€ŸåŠ¨ç”»å¾ªç¯ ---
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. å¿«é€Ÿæ’å€¼ï¼šè®© handOpenness è¿…é€Ÿè¿½ä¸Š targetOpenness
            // 0.25 çš„ç³»æ•°éå¸¸å¿«ï¼Œå‡ ä¹æ²¡æœ‰å»¶è¿Ÿ
            handOpenness += (targetOpenness - handOpenness) * 0.25;

            const pos = particleSystem.geometry.attributes.position.array;
            
            // å‘¼å¸æ„Ÿéœ‡å¹…
            const breath = Math.sin(time) * 0.05;

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

                const bx = targetPositions[ix];
                const by = targetPositions[iy];
                const bz = targetPositions[iz];

                // 2. è®¡ç®—ç›®æ ‡ä½ç½®
                // å¦‚æœæ‰‹å¼ å¼€ï¼Œç›®æ ‡ä½ç½® = åŸä½ + å‘å¤–çˆ†ç‚¸çš„åç§»é‡
                // åç§»é‡åŸºäºåŸç‚¹æ–¹å‘ (bx,by,bz) åŠ ä¸Šä¸€äº›éšæœºæ‰°åŠ¨ (randomOffsets)
                
                const spread = handOpenness * 35; // æœ€å¤§çˆ†ç‚¸èŒƒå›´
                
                // çˆ†ç‚¸æ–¹å‘ = åŸç‚¹æ–¹å‘ + éšæœºæ‚ä¹±åº¦
                const dirX = bx + randomOffsets[ix] * 10;
                const dirY = by + randomOffsets[iy] * 10;
                const dirZ = bz + randomOffsets[iz] * 10;
                
                // æœ€ç»ˆç›®æ ‡åç§»
                const tx = bx + dirX * spread * 0.05;
                const ty = by + dirY * spread * 0.05;
                const tz = bz + dirZ * spread * 0.05;

                // 3. ç²’å­è¿åŠ¨ (Lerp)
                // 0.2 çš„é€Ÿåº¦æå¿«ï¼Œæ‰‹ä¸€æ¾ï¼Œç²’å­é©¬ä¸Šå¸å›åŸå½¢
                pos[ix] += (tx - pos[ix]) * 0.2;
                pos[iy] += (ty - pos[iy]) * 0.2;
                pos[iz] += (tz - pos[iz]) * 0.2;
            }

            // æ•´ä½“æ—‹è½¬
            particleSystem.rotation.y += 0.003;
            // éšæ‰‹åŠ¿ç¼©æ”¾
            const scale = 1 + breath + handOpenness * 0.3;
            particleSystem.scale.setScalar(scale);

            particleSystem.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
