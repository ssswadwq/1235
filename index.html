<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Style ç²’å­æ‰‹åŠ¿äº¤äº’ - å¢å¼ºç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* --- ä¿®æ”¹ï¼šéšè—æ‘„åƒå¤´ï¼Œä½†åœ¨åå°è¿è¡Œ --- */
        #video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }
        #input-video { width: 1px; height: 1px; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(15px);
            padding: 24px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: white;
            z-index: 100;
            width: 260px;
            box-shadow: 0 10px 40px 0 rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
        }
        
        #ui-panel:hover {
            border-color: rgba(255, 255, 255, 0.2);
        }

        h1 { font-size: 18px; margin: 0 0 20px 0; color: #fff; font-weight: 600; background: linear-gradient(90deg, #a4c2f4, #ff88cc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .control-group { margin-bottom: 20px; }
        label { display: block; font-size: 12px; margin-bottom: 8px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        
        /* æŒ‰é’®ç½‘æ ¼ä¼˜åŒ– */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        
        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: #ddd;
            padding: 10px 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-2px); }
        button.active { background: rgba(66, 133, 244, 0.2); border-color: #4285f4; color: #fff; box-shadow: 0 0 15px rgba(66, 133, 244, 0.3); }

        input[type="color"] {
            width: 100%;
            height: 36px;
            border: none;
            background: none;
            cursor: pointer;
            border-radius: 8px;
        }

        #status {
            font-size: 13px;
            color: #aaa;
            margin-top: 10px;
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 8px;
        }
        .dot { width: 8px; height: 8px; background: #555; border-radius: 50%; margin-right: 10px; transition: background 0.3s; }
        .dot.active { background: #4cd964; box-shadow: 0 0 8px #4cd964; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 16px; pointer-events: none; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹...</div>

    <div id="ui-panel">
        <h1>âœ¨ ç²’å­äº¤äº’æ§åˆ¶å™¨</h1>
        
        <div class="control-group">
            <label>æ¨¡å‹é€‰æ‹©</label>
            <div class="btn-grid">
                <button onclick="changeShape('heart')" class="active"><span>â¤ï¸</span>çˆ±å¿ƒ</button>
                <button onclick="changeShape('galaxy')"><span>ğŸŒŒ</span>æ˜Ÿç³»</button>
                <button onclick="changeShape('dna')"><span>ğŸ§¬</span>DNA</button>
                
                <button onclick="changeShape('saturn')"><span>ğŸª</span>åœŸæ˜Ÿ</button>
                <button onclick="changeShape('cube')"><span>ğŸ§Š</span>ç«‹æ–¹</button>
                <button onclick="changeShape('sphere')"><span>ğŸ”®</span>çƒä½“</button>
                
                <button onclick="changeShape('flower')"><span>ğŸŒ¸</span>èŠ±æœµ</button>
                <button onclick="changeShape('text')"><span>ğŸ‡¨ğŸ‡³</span>æ–‡å­—</button>
                <button onclick="changeShape('buddha')"><span>ğŸ§˜</span>ä½›åƒ</button>
            </div>
        </div>

        <div class="control-group">
            <label>ç²’å­é¢œè‰²</label>
            <input type="color" id="colorPicker" value="#ff88cc">
        </div>

        <div class="control-group">
            <label>è¯†åˆ«çŠ¶æ€</label>
            <div id="status"><div class="dot" id="status-dot"></div><span id="status-text">å¯åŠ¨æ‘„åƒå¤´...</span></div>
        </div>
        
        <button style="width:100%; margin-top:10px; flex-direction:row;" onclick="toggleFullScreen()">â›¶ è¿›å…¥æ²‰æµ¸æ¨¡å¼</button>
    </div>

    <!-- éšè—çš„è§†é¢‘å®¹å™¨ -->
    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <script>
        // --- 1. åˆå§‹åŒ– Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.025); // æ›´æ·±é‚ƒçš„èƒŒæ™¯

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 2. ç²’å­ç³»ç»Ÿ ---
        const particleCount = 20000; // å¢åŠ ç²’å­æ•°é‡ä»¥è·å¾—æ›´ç»†è…»çš„æ•ˆæœ
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 150;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0xff88cc,
            size: 0.2, // ç¨å¾®è°ƒå°ç²’å­
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 3. å½¢çŠ¶ç®—æ³•åº“ ---
        
        function getPointOnHeart(t) {
            t = t * Math.PI * 2;
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            return { x: x * 0.5, y: y * 0.5, z: (Math.random() - 0.5) * 4 };
        }

        function getPointOnSphere() {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = 10;
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        // æ–°å¢ï¼šDNA åŒèºæ—‹
        function getPointOnHelix(i, total) {
            const t = (i / total) * Math.PI * 20; // åœˆæ•°
            const r = 5; 
            // åŒé“¾é€»è¾‘ï¼šå¶æ•°ä¸€æ¡é“¾ï¼Œå¥‡æ•°ä¸€æ¡é“¾
            const offset = (i % 2 === 0) ? 0 : Math.PI;
            return {
                x: r * Math.cos(t + offset),
                y: (i / total - 0.5) * 30, // æ‹‰é•¿Yè½´
                z: r * Math.sin(t + offset)
            };
        }

        // æ–°å¢ï¼šæ˜Ÿç³»æ¼©æ¶¡
        function getPointOnGalaxy() {
            const arms = 3;
            const armAngle = (Math.random() * Math.PI * 2 * arms);
            const distance = Math.pow(Math.random(), 2) * 15; // èšé›†åœ¨ä¸­å¿ƒ
            const curve = 1.5; // æ—‹è½¬æ›²ç‡
            
            // æåæ ‡è½¬ç›´è§’åæ ‡ï¼ŒåŠ ä¸Šéšæœºåç§»ä½œä¸ºâ€œåšåº¦â€
            const angle = armAngle / arms + distance * curve;
            return {
                x: Math.cos(angle) * distance + (Math.random()-0.5),
                y: (Math.random()-0.5) * (20 - distance) * 0.1, // ä¸­å¿ƒåšè¾¹ç¼˜è–„
                z: Math.sin(angle) * distance + (Math.random()-0.5)
            };
        }

        // æ–°å¢ï¼šç«‹æ–¹ä½“ (è¡¨é¢)
        function getPointOnCube() {
            const s = 14; // è¾¹é•¿
            // éšæœºé€‰æ‹©ä¸€ä¸ªé¢ (0-5)
            const face = Math.floor(Math.random() * 6);
            let x, y, z;
            const r1 = (Math.random() - 0.5) * s;
            const r2 = (Math.random() - 0.5) * s;
            const half = s / 2;

            switch(face) {
                case 0: x = half; y = r1; z = r2; break;
                case 1: x = -half; y = r1; z = r2; break;
                case 2: y = half; x = r1; z = r2; break;
                case 3: y = -half; x = r1; z = r2; break;
                case 4: z = half; x = r1; y = r2; break;
                case 5: z = -half; x = r1; y = r2; break;
            }
            return { x, y, z };
        }

        function getPointOnSaturn() {
            if (Math.random() > 0.4) {
                return getPointOnSphere();
            } else {
                const angle = Math.random() * Math.PI * 2;
                const r = 14 + Math.random() * 6;
                return { x: r * Math.cos(angle), y: (Math.random()-0.5) * 0.5, z: r * Math.sin(angle) };
            }
        }
        
        function getPointOnFlower() {
            const angle = Math.random() * Math.PI * 2;
            const r = 10 * Math.sin(4 * angle);
            const phi = (Math.random() - 0.5) * Math.PI;
            return {
                x: r * Math.cos(angle) * Math.cos(phi),
                y: r * Math.sin(angle) * Math.cos(phi),
                z: r * Math.sin(phi)
            };
        }

        function createTextPoints(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 200; canvas.height = 200;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 120px "Microsoft YaHei", sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);
            const imageData = ctx.getImageData(0, 0, 200, 200);
            const points = [];
            for (let y = 0; y < 200; y += 2) {
                for (let x = 0; x < 200; x += 2) {
                    if (imageData.data[(y * 200 + x) * 4 + 3] > 128) {
                        points.push({
                            x: (x - 100) * 0.15,
                            y: -(y - 100) * 0.15,
                            z: (Math.random() - 0.5) * 2
                        });
                    }
                }
            }
            return points;
        }

        // --- 4. é€»è¾‘æ§åˆ¶ ---
        let currentShape = 'heart';
        
        function updateTargetPositions(shapeType) {
            let textPoints = [];
            if (shapeType === 'text') textPoints = createTextPoints("ä¼šå®");
            if (shapeType === 'buddha') textPoints = createTextPoints("ä½›");

            for (let i = 0; i < particleCount; i++) {
                let p = {x:0, y:0, z:0};
                
                switch(shapeType) {
                    case 'heart': p = getPointOnHeart(Math.random()); break;
                    case 'sphere': p = getPointOnSphere(); break;
                    case 'saturn': p = getPointOnSaturn(); break;
                    case 'flower': p = getPointOnFlower(); break;
                    case 'dna': p = getPointOnHelix(i, particleCount); break;
                    case 'cube': p = getPointOnCube(); break;
                    case 'galaxy': p = getPointOnGalaxy(); break;
                    case 'text': 
                    case 'buddha':
                        const tp = textPoints[i % textPoints.length];
                        p = { x: tp.x * 1.5, y: tp.y * 1.5, z: tp.z };
                        break;
                }

                targetPositions[i * 3] = p.x;
                targetPositions[i * 3 + 1] = p.y;
                targetPositions[i * 3 + 2] = p.z;
            }
        }

        updateTargetPositions('heart');

        window.changeShape = (shape) => {
            currentShape = shape;
            updateTargetPositions(shape);
            document.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            // æŸ¥æ‰¾æœ€è¿‘çš„buttonçˆ¶çº§ï¼ˆå› ä¸ºç‚¹å‡»å¯èƒ½ç‚¹åˆ°spanï¼‰
            event.currentTarget.classList.add('active');
        };

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });

        window.toggleFullScreen = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        };

        // --- 5. MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        let handOpenness = 0;
        const videoElement = document.getElementById('input-video');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const loadingElement = document.getElementById('loading');

        function onResults(results) {
            loadingElement.style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('active');
                statusText.innerText = "æ‰‹åŠ¿äº¤äº’ä¸­";
                
                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // è°ƒæ•´çµæ•åº¦ï¼šæåˆ<0.05, å¼ å¼€>0.2
                let rawOpenness = (distance - 0.05) * 6; 
                rawOpenness = Math.max(0, Math.min(1, rawOpenness));
                handOpenness += (rawOpenness - handOpenness) * 0.15;
            } else {
                statusDot.classList.remove('active');
                statusText.innerText = "å¯»æ‰¾æ‰‹éƒ¨...";
                handOpenness += (0 - handOpenness) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 320, height: 240
        });
        cameraUtils.start();

        // --- 6. åŠ¨ç”»å¾ªç¯ ---
        let time = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.008;

            const positionsArray = particleSystem.geometry.attributes.position.array;
            
            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const tx = targetPositions[ix];
                const ty = targetPositions[iy];
                const tz = targetPositions[iz];

                // ç¼“åŠ¨åŠ¨ç”»
                positionsArray[ix] += (tx - positionsArray[ix]) * 0.04;
                positionsArray[iy] += (ty - positionsArray[iy]) * 0.04;
                positionsArray[iz] += (tz - positionsArray[iz]) * 0.04;

                // äº¤äº’æ•ˆæœ
                if (handOpenness > 0.05) {
                    const explosion = handOpenness * 20; 
                    // åŠ ä¸ŠéšæœºæŠ–åŠ¨ï¼Œè¥é€ èƒ½é‡æ„Ÿ
                    const noiseX = Math.sin(time * 5 + iy) * 0.2;
                    const noiseY = Math.cos(time * 5 + ix) * 0.2;
                    
                    // åŸºäºåŸç‚¹å‘å¤–æ¨
                    positionsArray[ix] += (positionsArray[ix] * 0.01 + noiseX) * explosion;
                    positionsArray[iy] += (positionsArray[iy] * 0.01 + noiseY) * explosion;
                    positionsArray[iz] += (positionsArray[iz] * 0.01) * explosion;
                }
            }

            // æ•´ä½“æ—‹è½¬ï¼šDNAå’ŒGalaxyæ—‹è½¬å¿«ä¸€ç‚¹å¥½çœ‹
            let rotationSpeed = 0.002;
            if (currentShape === 'dna' || currentShape === 'galaxy') rotationSpeed = 0.005;
            
            particleSystem.rotation.y += rotationSpeed;
            
            // å‘¼å¸æ„Ÿ
            const breath = 1 + Math.sin(time) * 0.05;
            const targetScale = breath + handOpenness * 0.8;
            particleSystem.scale.setScalar(
                particleSystem.scale.x + (targetScale - particleSystem.scale.x) * 0.1
            );

            particleSystem.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
